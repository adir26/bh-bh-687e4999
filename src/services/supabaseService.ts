import { supabase } from '@/integrations/supabase/client';

export interface Category {
  id: string;
  name: string;
  description?: string;
  icon?: string;
  parent_id?: string;
  created_at: string;
}

export interface Company {
  id: string;
  owner_id: string;
  name: string;
  description?: string;
  website?: string;
  logo_url?: string;
  address?: string;
  city?: string;
  phone?: string;
  email?: string;
  rating: number;
  review_count: number;
  verified: boolean;
  created_at: string;
  updated_at: string;
  slug: string;
}

export interface Project {
  id: string;
  client_id: string;
  title: string;
  description?: string;
  category_id?: string;
  budget_min?: number;
  budget_max?: number;
  location?: string;
  status: 'planning' | 'active' | 'completed' | 'cancelled';
  start_date?: string;
  end_date?: string;
  created_at: string;
  updated_at: string;
}

export interface Order {
  id: string;
  project_id: string;
  supplier_id: string;
  client_id: string;
  title: string;
  description?: string;
  amount: number;
  status: 'pending' | 'confirmed' | 'in_progress' | 'completed' | 'cancelled';
  due_date?: string;
  completed_at?: string;
  created_at: string;
  updated_at: string;
}

export interface Message {
  id: string;
  sender_id: string;
  recipient_id: string;
  project_id?: string;
  order_id?: string;
  content: string;
  status: 'sent' | 'delivered' | 'read';
  read_at?: string;
  created_at: string;
}

export interface Review {
  id: string;
  reviewer_id: string;
  reviewed_id: string;
  project_id?: string;
  order_id?: string;
  rating: number;
  title?: string;
  content?: string;
  created_at: string;
}

// Legacy interface - keeping for backward compatibility
export interface HomepageContent {
  id: string;
  block_name: string;
  content_data: any;
  is_enabled: boolean;
  display_order: number;
  start_date?: string;
  end_date?: string;
  created_at: string;
  updated_at: string;
}

// Categories Service
export const categoriesService = {
  async getAll() {
    const { data, error } = await supabase
      .from('categories')
      .select('*')
      .order('name');
    
    if (error) throw error;
    return data as Category[];
  },

  async getById(id: string) {
    const { data, error } = await supabase
      .from('categories')
      .select('*')
      .eq('id', id)
      .maybeSingle();
    
    if (error) throw error;
    return data as Category;
  }
};

// Companies Service
export const companiesService = {
  async getAll() {
    const { data, error } = await supabase
      .from('companies')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Company[];
  },

  async getByOwnerId(ownerId: string) {
    const { data, error } = await supabase
      .from('companies')
      .select('*')
      .eq('owner_id', ownerId)
      .maybeSingle();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data as Company | null;
  },

  async create(company: Omit<Company, 'id' | 'created_at' | 'updated_at' | 'rating' | 'review_count' | 'verified' | 'slug'>) {
    const { data, error } = await supabase
      .from('companies')
      .insert({
        ...company,
        slug: null // Will be auto-generated by trigger
      })
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Company;
  },

  async update(id: string, updates: Partial<Company>) {
    const { data, error } = await supabase
      .from('companies')
      .update(updates)
      .eq('id', id)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Company;
  }
};

// Projects Service
export const projectsService = {
  async getAll() {
    const { data, error } = await supabase
      .from('projects')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Project[];
  },

  async getByClientId(clientId: string) {
    const { data, error } = await supabase
      .from('projects')
      .select('*')
      .eq('client_id', clientId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Project[];
  },

  async create(project: Omit<Project, 'id' | 'created_at' | 'updated_at'>) {
    const { data, error } = await supabase
      .from('projects')
      .insert(project)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Project;
  },

  async update(id: string, updates: Partial<Project>) {
    const { data, error } = await supabase
      .from('projects')
      .update(updates)
      .eq('id', id)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Project;
  }
};

// Orders Service
export const ordersService = {
  async getAll() {
    const { data, error } = await supabase
      .from('orders')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Order[];
  },

  async getByUserId(userId: string) {
    try {
      const { data, error } = await supabase
        .from('orders')
        .select('*')
        .or(`client_id.eq.${userId},supplier_id.eq.${userId}`)
        .order('created_at', { ascending: false });
      
      if (error) {
        // Enhanced error logging and handling
        console.error('Supabase orders query error:', error);
        
        // Handle specific error codes
        if (error.code === '42P01' || error.message?.includes('does not exist')) {
          console.log('Orders table does not exist, returning empty array');
          return [];
        }
        if (error.code === 'PGRST301' || error.message?.includes('permission denied')) {
          console.log('Permission denied for orders table, returning empty array');
          return [];
        }
        
        throw error;
      }
      
      return (data as Order[]) || [];
    } catch (error) {
      console.error('Error in ordersService.getByUserId:', error);
      throw error;
    }
  },

  async create(order: Omit<Order, 'id' | 'created_at' | 'updated_at'>) {
    const { data, error } = await supabase
      .from('orders')
      .insert(order)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Order;
  },

  async update(id: string, updates: Partial<Order>) {
    const { data, error } = await supabase
      .from('orders')
      .update(updates)
      .eq('id', id)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Order;
  }
};

// Messages Service
export const messagesService = {
  async getByUserId(userId: string) {
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .or(`sender_id.eq.${userId},recipient_id.eq.${userId}`)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Message[];
  },

  async send(message: Omit<Message, 'id' | 'created_at' | 'status' | 'read_at'>) {
    const { data, error } = await supabase
      .from('messages')
      .insert(message)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Message;
  },

  async markAsRead(id: string) {
    const { data, error } = await supabase
      .from('messages')
      .update({ 
        status: 'read', 
        read_at: new Date().toISOString() 
      })
      .eq('id', id)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Message;
  }
};

// Reviews Service
export const reviewsService = {
  async getAll() {
    const { data, error } = await supabase
      .from('reviews')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Review[];
  },

  async getByReviewedId(reviewedId: string) {
    const { data, error } = await supabase
      .from('reviews')
      .select('*')
      .eq('reviewed_id', reviewedId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data as Review[];
  },

  async create(review: Omit<Review, 'id' | 'created_at'>) {
    const { data, error } = await supabase
      .from('reviews')
      .insert(review)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as Review;
  }
};

// Profiles Service
export const profilesService = {
  async getProfile(userId: string) {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .maybeSingle();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data;
  },

  async updateProfile(userId: string, updates: any) {
    // Filter out security-sensitive fields
    const { role, id, created_at, updated_at, ...safeUpdates } = updates;
    
    const { data, error } = await supabase
      .from('profiles')
      .update(safeUpdates)
      .eq('id', userId)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data;
  },

  async getAllProfiles() {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  }
};

// Admin Service
export const adminService = {
  async getStats() {
    const { data: users, error: usersError } = await supabase
      .from('profiles')
      .select('id, role, created_at')
      .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());
    
    if (usersError) throw usersError;

    const { data: orders, error: ordersError } = await supabase
      .from('orders')
      .select('*');
    
    if (ordersError) throw ordersError;

    const { data: allUsers, error: allUsersError } = await supabase
      .from('profiles')
      .select('id, role');
    
    if (allUsersError) throw allUsersError;

    const totalUsers = allUsers.length;
    const suppliers = allUsers.filter(user => user.role === 'supplier').length;
    const clients = allUsers.filter(user => user.role === 'client').length;
    const newUsersThisMonth = users.length;
    const activeToday = Math.floor(totalUsers * 0.23); // Mock active today percentage
    const totalOrders = orders.length;
    const totalRevenue = orders.reduce((sum, order) => sum + Number(order.amount), 0);
    const pendingOrders = orders.filter(order => order.status === 'pending').length;
    const completedOrders = orders.filter(order => order.status === 'completed').length;

    return {
      users: {
        total: totalUsers,
        suppliers,
        clients,
        newThisMonth: newUsersThisMonth,
        activeToday
      },
      orders: {
        total: totalOrders,
        revenue: totalRevenue,
        pending: pendingOrders,
        completed: completedOrders
      }
    };
  }
};

// Supplier Service
export const supplierService = {
  async getSupplierStats(supplierId: string) {
    const { data: orders, error: ordersError } = await supabase
      .from('orders')
      .select('*')
      .eq('supplier_id', supplierId);
    
    if (ordersError) throw ordersError;

    const { data: reviews, error: reviewsError } = await supabase
      .from('reviews')
      .select('*')
      .eq('reviewed_id', supplierId);
    
    if (reviewsError) throw reviewsError;

    const { data: company, error: companyError } = await supabase
      .from('companies')
      .select('*')
      .eq('owner_id', supplierId)
      .maybeSingle();
    
    if (companyError && companyError.code !== 'PGRST116') throw companyError;

    const thisWeekStart = new Date();
    thisWeekStart.setDate(thisWeekStart.getDate() - 7);
    
    const newLeadsThisWeek = orders.filter(order => 
      new Date(order.created_at) >= thisWeekStart && order.status === 'pending'
    ).length;
    
    const activeOrders = orders.filter(order => 
      !['completed', 'cancelled'].includes(order.status)
    ).length;
    
    const avgRating = reviews.length > 0 
      ? reviews.reduce((sum, review) => sum + review.rating, 0) / reviews.length 
      : 0;
    
    const thisMonthRevenue = orders
      .filter(order => {
        const orderDate = new Date(order.created_at);
        const currentMonth = new Date();
        return orderDate.getMonth() === currentMonth.getMonth() && 
               orderDate.getFullYear() === currentMonth.getFullYear();
      })
      .reduce((sum, order) => sum + Number(order.amount), 0);

    return {
      newLeadsThisWeek,
      activeOrders,
      avgRating: avgRating.toFixed(1),
      thisMonthRevenue,
      company
    };
  }
};

// Homepage Content Service
export const homepageContentService = {
  async getAll() {
    const { data, error } = await supabase
      .from('homepage_content')
      .select('*')
      .order('display_order');
    
    if (error) throw error;
    return data as HomepageContent[];
  },

  async getEnabled() {
    const { data, error } = await supabase
      .from('homepage_content')
      .select('*')
      .eq('is_enabled', true)
      .order('display_order');
    
    if (error) throw error;
    return data as HomepageContent[];
  },

  async getByBlockName(blockName: string) {
    const { data, error } = await supabase
      .from('homepage_content')
      .select('*')
      .eq('block_name', blockName)
      .maybeSingle();
    
    if (error && error.code !== 'PGRST116') throw error;
    return data as HomepageContent | null;
  },

  async update(id: string, updates: Partial<HomepageContent>) {
    const { data, error } = await supabase
      .from('homepage_content')
      .update(updates)
      .eq('id', id)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as HomepageContent;
  },

  async updateByBlockName(blockName: string, updates: Partial<HomepageContent>) {
    const { data, error } = await supabase
      .from('homepage_content')
      .update(updates)
      .eq('block_name', blockName)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as HomepageContent;
  },

  async create(content: Omit<HomepageContent, 'id' | 'created_at' | 'updated_at'>) {
    const { data, error } = await supabase
      .from('homepage_content')
      .insert(content)
      .select()
      .maybeSingle();
    
    if (error) throw error;
    return data as HomepageContent;
  }
};

// Storage Service
export const storageService = {
  async uploadAvatar(userId: string, file: File) {
    const fileExt = file.name.split('.').pop();
    const fileName = `${userId}/avatar.${fileExt}`;
    
    const { error: uploadError } = await supabase.storage
      .from('avatars')
      .upload(fileName, file, { upsert: true });
    
    if (uploadError) throw uploadError;
    
    const { data } = supabase.storage
      .from('avatars')
      .getPublicUrl(fileName);
    
    return data.publicUrl;
  },

  async uploadCompanyLogo(companyId: string, file: File) {
    const fileExt = file.name.split('.').pop();
    const fileName = `${companyId}/logo.${fileExt}`;
    
    const { error: uploadError } = await supabase.storage
      .from('company-logos')
      .upload(fileName, file, { upsert: true });
    
    if (uploadError) throw uploadError;
    
    const { data } = supabase.storage
      .from('company-logos')
      .getPublicUrl(fileName);
    
    return data.publicUrl;
  },

  async uploadProjectDocument(projectId: string, file: File) {
    const fileExt = file.name.split('.').pop();
    const fileName = `${projectId}/${Date.now()}.${fileExt}`;
    
    const { error: uploadError } = await supabase.storage
      .from('project-documents')
      .upload(fileName, file);
    
    if (uploadError) throw uploadError;
    
    const { data } = supabase.storage
      .from('project-documents')
      .getPublicUrl(fileName);
    
    return data.publicUrl;
  },

  async uploadMarketingBanner(file: File) {
    const fileExt = file.name.split('.').pop();
    const fileName = `banners/${Date.now()}.${fileExt}`;
    
    const { error: uploadError } = await supabase.storage
      .from('company-logos') // Using existing public bucket
      .upload(fileName, file);
    
    if (uploadError) throw uploadError;
    
    const { data } = supabase.storage
      .from('company-logos')
      .getPublicUrl(fileName);
    
    return data.publicUrl;
  }
};